<?xml version="1.0" encoding="utf-16"?>
<!-- Generated with EZOut 1.9.7: Install-Module EZOut or https://github.com/StartAutomating/EZOut -->
<Types>
  <Type>
    <Name>Demo</Name>
    <Members>
      <ScriptMethod>
        <Name>ColorizeStep</Name>
        <Script>
                        param($step)

$stepTokens = [Management.Automation.PSParser]::Tokenize($step, [ref]$null)
$PreviousToken = $null
foreach ($_ in $stepTokens) {   
    $content = $_.Content
    if ($_.Type -in 'Variable', 'String') {
        $content = $step.Substring($_.Start, $_.Length)
    }
    if ($PreviousToken) {
        $token = $_
        $prevEnd = $PreviousToken.Start + $PreviousToken.Length
        $substring = $step.Substring($prevEnd, $token.Start -  $prevEnd)
        if ($substring) {
            @{InputObject=$substring}
        }
    }
    
    if ($_.Type -eq 'Comment') {
        @{
            ForegroundColor='Success'
            InputObject = $content
        }
    }
    elseif ($_.Type -in 'Keyword', 'String', 'CommandArgument') {
        @{
            ForegroundColor='Verbose'
            InputObject = $Content
        }
    }
    elseif ($_.Type -in 'Variable', 'Command') {
        @{
            ForegroundColor='Warning'
            InputObject = $Content
        }   
    }
    elseif ($_.Type -in 'CommandParameter') {
        @{
            ForegroundColor='Magenta'
            InputObject = $Content
        }        
    }
    elseif (
        $_.Type -in 'Operator','GroupStart', 'GroupEnd'
    ) {
        @{
            ForegroundColor='Magenta'
            InputObject = $Content
        }
    }
    elseif (
        $_.Type -notin 'Comment', 
            'Keyword', 'String', 'CommandArgument',
            'Variable', 'Command',
            'CommandParameter',
            'Operator','GroupStart', 'GroupEnd'
    )  {
        @{
            ForegroundColor='Output'
            InputObject=$Content
        }
    } else {
        @{
            ForegroundColor='Output'
            InputObject=$Content
        }
    }
    $PreviousToken = $_
}
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Dump</Name>
        <Script>
                        $demoContent =
@(foreach ($chapter in $this.Chapters) {
    "# $($chapter.Number) $($chapter.Name)"
    $stepIndex = 0
    foreach ($step in $chapter.Steps) {
        $stepIndex++
        if ($this.CurrentChapter -eq $chapter -and $this.CurrentStep -eq $stepIndex) {
            "    &lt;# *** You Are Here! *** #&gt;"
        }
        $step

    }
}) -join [Environment]::NewLine

$demoContent
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>NextChapter</Name>
        <Script>
                        $demo = $this
$chapterIndex = $demo.Chapters.IndexOf($demo.CurrentChapter)
$chapterIndex++
if (-not $demo.Chapters[$chapterIndex]) {
    $demo | Add-Member NoteProperty DemoFinished ([datetime]::Now) -Force
} else {
    $demo | Add-Member NoteProperty CurrentChapter $demo.Chapters[$chapterIndex] -Force
    $demo | Add-Member NoteProperty CurrentStep 0 -Force
}
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>NextStep</Name>
        <Script>
                        $demo = $this
$demo.CurrentStep++
# No more steps in this chapter
if (-not $demo.CurrentChapter.Steps[$demo.CurrentStep - 1]) {
    $demo.NextChapter()
}
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Reset</Name>
        <Script>
                        $this | Add-Member NoteProperty Status "NotStarted" -Force
$this | Add-Member NoteProperty StepToRun $null -Force
$demo | Add-Member NoteProperty DemoFinished $null -Force
$demo | Add-Member NoteProperty DemoStarted  $null -Force
$demo | Add-Member NoteProperty CurrentChapter $null -Force
$demo | Add-Member NoteProperty CurrentStep $null -Force
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>SetStatus</Name>
        <Script>
                        param([string]$Status)

$this | Add-Member Status $status -Force
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Start</Name>
        <Script>
                        $this | Add-Member NoteProperty Status Running -Force
$this | Add-Member NoteProperty DemoStarted ([DateTime]::Now) -Force
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Stop</Name>
        <Script>
                        $this | Add-Member NoteProperty Status Stopped -Force
$this | Add-Member NoteProperty StepToRun $null -Force
$this | Add-Member NoteProperty DemoFinished ([datetime]::Now) -Force
$demo | Add-Member NoteProperty CurrentChapter $null -Force
$demo | Add-Member NoteProperty CurrentStep $null -Force
                    </Script>
      </ScriptMethod>
      <ScriptProperty>
        <Name>TotalSteps</Name>
        <GetScriptBlock>
                        $stepCount = 0
foreach ($chapter in $this.Chapters) {
    $stepCount += $chapter.Steps.Length
}
$stepCount
                    </GetScriptBlock>
      </ScriptProperty>
    </Members>
  </Type>
  <Type>
    <Name>Demo.Chapter</Name>
    <Members>
      <ScriptProperty>
        <Name>Steps</Name>
        <GetScriptBlock>
                        $text = $this.Text
$step = @()

# We want every step to be able to run independently.
# This would be untrue if the code is unbalanced when a chapter would start
# Thus, while we're primarily looking for comments, we also need to track groups
$groupDepth  = 0 
for ($tokenNumber =0 ; $tokenNumber -lt $this.Tokens.Length; $tokenNumber++) {
    $token = $this.tokens[$tokenNumber]
    # If the token is a group start
    if ($token.Type -eq 'GroupStart') 
    {
        $groupDepth++ # increment depth.
    }
    # If the token was a group end
    elseif ($token.Type -eq 'GroupEnd')
    {
        $groupDepth-- # decrement depth.
    }
    # If there was no depth
    # and the token was a comment starting in the first column.
    elseif (                
        (-not $groupDepth) -and            
        $token.StartColumn -le 1
    ) {
        # Then it's the start of a new step
        if ($step) {
            $stepEnd = $step[-1].Start + $step[-1].Length
            $stepStart = $step[0].Start
            # Get the content of the last step
            $stepScript = $text.Substring($stepStart, $stepEnd - $stepStart) -replace '^\s{0,}$'
            if ($stepScript) {
                # and make it into a PSObject
                $stepScript = [PSObject]::new($stepScript)
                # with the PSTypeName 'Demo.Step'
                $stepScript.pstypenames.add('Demo.Step')
                # and add the .Chapter property, pointing to $this
                $stepScript.psobject.properties.add([psnoteproperty]::new(
                    'Chapter',$this
                ))
                
                $stepScript
            }
            # then reset the collection of tokens in the current step.
            $step = @()
        }        
    }

    # Add any token we see into the current step.
    $step += $token
}

# If there were any steps remaining
if ($step) {    
    $stepEnd = $step[-1].Start + $step[-1].Length
    $stepStart = $step[0].Start
    $stepScript = $text.Substring($stepStart, $stepEnd - $stepStart) -replace '^\s{0,}$'
    if ($stepScript) {
        # make them into 'Demo.Step' objects
        $stepScript = [PSObject]::new($stepScript)
        $stepScript.pstypenames.add('Demo.Step')
        $stepScript.psobject.properties.add([psnoteproperty]::new(
            'Chapter',$this
        )) # and add the chapter.
        $stepScript
    }
}

                    </GetScriptBlock>
      </ScriptProperty>
    </Members>
  </Type>
  <Type>
    <Name>Demo.Step</Name>
    <Members>
      <ScriptProperty>
        <Name>IsComment</Name>
        <GetScriptBlock>
                        $stepTokens = [Management.Automation.PSParser]::Tokenize($this, [ref]$null)
foreach ($token in $stepTokens) {
    if ($token.Type -notin 'Comment', 'Newline') {
        return $false
    }
}
return $true
                    </GetScriptBlock>
      </ScriptProperty>
    </Members>
  </Type>
</Types>
